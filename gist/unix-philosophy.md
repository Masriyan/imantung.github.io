---
layout: gist
title: Unix Philosophy
---

# Unix Philosophy

<http://www.faqs.org/docs/artu/ch01s06.html>

Unix Philosophy:
1. Write programs that do one thing and do it well.
2. Write programs to work together.
3. Write programs to handle text streams, because that is a universal interface.

Unix rule/principle:
1. Write simple parts connected by clean interfaces. (Rule of Modularity)
2. Clarity is better than cleverness. (Rule of Clarity)
3. Design programs to be connected to other programs. (Rule of Composition)
4. Separate policy from mechanism; separate interfaces from engines. (Rule of Separation)
5. Design for simplicity; add complexity only where you must. (Rule of Simplicity)
6. Write a big program only when it is clear by demonstration that nothing else will do. (Rule of Parsimony)
7. Design for visibility to make inspection and debuggingeasier. (Rule of Transparency)
8. Robustness is the child of transparency and simplicity.(Rule of Robustness)
9. Fold knowledge into data so program logic can be stupid and robust. (Rule of Representation)
10. In interface design, always do the least surprising thing. (Rule of Least Surprise)
11. When a program has nothing surprising to say, it should say nothing. (Rule of Silence)
12. When you must fail, fail noisily and as soon as possible. (Rule of Repair)
13. Programmer time is expensive; conserve it in preference to machine time. (Rule of Economy)
14. Avoid hand-hacking; write programs to write programs when you can. (Rule of Generation)
15. Prototype before polishing. Get it working before you optimize it. (Rule of Optimization)
16. Distrust all claims for “one true way”. (Rule of Diversity)
17. Design for the future, because it will be here sooner than you think. (Rule of Extensibility)
